package js.node;

/*
 * Copyright (C)2014-2019 Haxe Foundation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
import js.node.http2.Http2Constants;
import haxe.extern.EitherType;
import haxe.io.ArrayBufferView;
import js.node.http2.ClientHttp2Session;
import js.node.http2.Http2SecureServer;
import js.node.http2.Http2Server;
import js.node.http2.Http2ServerResponse;
import js.node.http2.Http2Session;
import js.node.http.IncomingMessage;
import js.node.http2.Http2ServerRequest;
import js.node.tls.SecureContext;
import js.node.stream.Duplex;
import js.node.net.Socket;
#if haxe4
import js.lib.Error;
#else
import js.Error;
#end

/**
	The `http2` module provides an implementation of the HTTP/2 protocol.

	The Core API provides a low-level interface designed specifically around support
	for HTTP/2 protocol features.
	It is specifically not designed for compatibility with the existing HTTP/1 module API.
	However, the Compatibility API is.

	The `http2` Core API is much more symmetric between client and server than the `http` API.
	For instance, most events, like `'error'`, `'connect'` and `'stream'`, can be emitted either by client-side code or server-side code.

	@see https://nodejs.org/api/http2.html#http2_http_2
**/
@:jsRequire("http2")
extern class Http2 {
	/**
		Returns a `net.Server` instance that creates and manages `Http2Session` instances.

		@see https://nodejs.org/api/http2.html#http2_http2_createserver_options_onrequesthandler
	**/
	static function createServer(options:CreateServerOptions, ?onRequestHandler:Http2ServerRequest->Http2ServerResponse->Void):Http2Server;

	/**
		Returns a `tls.Server` instance that creates and manages `Http2Session` instances.

		@see https://nodejs.org/api/http2.html#http2_http2_createsecureserver_options_onrequesthandler
	**/
	static function createSecureServer(options:CreateSecureServerOptions, ?onRequestHandler:Http2ServerRequest->Http2ServerResponse->Void):Http2SecureServer;

	/**
		Returns a `ClientHttp2Session` instance.

		@see https://nodejs.org/api/http2.html#http2_http2_connect_authority_options_listener
	**/
	@:overload(function(authority:String, ?options:ConnectOptions, ?listener:Http2Session->Socket->Void):ClientHttp2Session {})
	static function connect(authority:Url, ?options:ConnectOptions, ?listener:Http2Session->Socket->Void):ClientHttp2Session;

	/**
		@see https://nodejs.org/api/http2.html#http2_http2_constants
	**/
	static var constants(default, never):Http2Constants;

	/**
		Returns an object containing the default settings for an Http2Session instance.
		This method returns a new object instance every time it is called
		so instances returned may be safely modified for use.

		@see https://nodejs.org/api/http2.html#http2_http2_getdefaultsettings
	**/
	static function getDefaultSettings():Http2SettingsObject;

	/**
		Returns a `Buffer` instance containing serialized representation of the given HTTP/2 settings
		as specified in the HTTP/2 specification.
		This is intended for use with the HTTP2-Settings header field.

		@see https://nodejs.org/api/http2.html#http2_http2_getpackedsettings_settings
	**/
	static function getPackedSettings(?settings:Http2SettingsObject):Buffer;

	/**
		Returns a `Http2SettingsObject` containing the deserialized settings from the given `Buffer`
		as generated by `http2.getPackedSettings()`.

		@see https://nodejs.org/api/http2.html#http2_http2_getunpackedsettings_buf
	**/
	@:overload(function(buf:Buffer):Http2SettingsObject {})
	static function getUnpackedSettings(buf:ArrayBufferView):Http2SettingsObject;
}

/**
	Type of the argument for
	* `Http2.getDefaultSettings()`
	* `Http2.getPackedSettings()`
	* `Http2.createServer()`
	* `Http2.createSecureServer()`
	* `Http2Session.settings()`
	* `Http2Session.localSettings`
	* `Http2Session.remoteSettings`
**/
typedef Http2SettingsObject = {
	/**
		Specifies the maximum number of bytes used for header compression.
		The minimum allowed value is 0. The maximum allowed value is 2^32-1.
		Default: `4,096` octets.
	**/
	@:optional var headerTableSize:Int;

	/**
		Specifies `true` if HTTP/2 Push Streams are to be permitted on the Http2Session instances.
	**/
	@:optional var enablePush:Bool;

	/**
		Specifies the senders initial window size for stream-level flow control. The minimum allowed value is 0.
		The maximum allowed value is 2^32-1.
		Default: `65,535` bytes.
	**/
	@:optional var initialWindowSize:Int;

	/**
		Specifies the size of the largest frame payload.
		The minimum allowed value is 16,384.
		The maximum allowed value is 2^24-1.
		Default: `16,384` bytes.
	**/
	@:optional var maxFrameSize:Int;

	/**
		Specifies the maximum number of concurrent streams permitted on an `Http2Session`.
		There is no default value which implies, at least theoretically,
		2^32-1 streams may be open concurrently at any given time in an `Http2Session`.
		The minimum value is 0.
		The maximum allowed value is 2^32-1.
		Default: `4294967295`.
	**/
	@:optional var maxConcurrentStreams:Int;

	/**
		Specifies the maximum size (uncompressed octets) of header list that will be accepted.
		The minimum allowed value is 0.
		The maximum allowed value is 2^32-1.
		Default: `65535`.
	**/
	@:optional var maxHeaderListSize:Int;

	/**
		Specifies `true` if the "Extended Connect Protocol" defined by RFC 8441 is to be enabled.
		This setting is only meaningful if sent by the server.
		Once the `enableConnectProtocol` setting has been enabled for a given `Http2Session`,
		it cannot be disabled.
	**/
	@:optional var enableConnectProtocol:Bool;
}

/**
	Headers are represented as own-properties on JavaScript objects.
	The property keys will be serialized to lower-case.
	Property values should be strings (if they are not they will be coerced to strings) or
	an `Array` of strings (in order to send more than one value per header field).

	@see https://nodejs.org/api/http2.html#http2_headers_object
**/
abstract HeadersObject(Dynamic) {
	inline function new() {
		this = {};
	}

	public var status(get, set):Int;

	extern inline function get_status() {
		return js.Syntax.code("{0}[':status']", this);
	}

	extern inline function set_status(value):Int {
		return js.Syntax.code("{0}[':status'] = {1}", this);
	}

	public var method(get, set):String;

	extern inline function get_method() {
		return js.Syntax.code("{0}[':method']", this);
	}

	extern inline function set_method(value) {
		return js.Syntax.code("{0}[':method'] = {1}", this, value);
	}

	public var authority(get, set):String;

	extern inline function get_authority() {
		return js.Syntax.code("{0}[':authority']", this);
	}

	extern inline function set_authority(value) {
		return js.Syntax.code("{0}[':authority'] = {1}", this, value);
	}

	public var scheme(get, set):String;

	extern inline function get_scheme() {
		return js.Syntax.code("{0}[':scheme']", this);
	}

	extern inline function set_scheme(value) {
		return js.Syntax.code("{0}[':scheme'] = {1}", this, value);
	}

	public var path(get, set):String;

	extern inline function get_path() {
		return js.Syntax.code("{0}[':path']", this);
	}

	extern inline function set_path(value) {
		return js.Syntax.code("{0}[':path']={1}", this, value);
	}

	public var protocol(get, set):String;

	extern inline function get_protocol() {
		return js.Syntax.code("{0}[':protocol']", this);
	}

	extern inline function set_protocol(value) {
		return js.Syntax.code("{0}[':protocol'] = {1}", this, value);
	}

	public var age(get, set):String;

	extern inline function get_age() {
		return js.Syntax.code("{0}['age']", this);
	}

	extern inline function set_age(value) {
		return js.Syntax.code("{0}['age'] = {1}", this, value);
	}

	public var authorization(get, set):String;

	extern inline function get_authorization() {
		return js.Syntax.code("{0}['authorization']", this);
	}

	extern inline function set_authorization(value) {
		return js.Syntax.code("{0}['authorization'] = {1}", this, value);
	}

	public var access_control_allow_credentials(get, set):String;

	extern inline function get_access_control_allow_credentials() {
		return js.Syntax.code("{0}['access-control-allow-credentials']", this);
	}

	extern inline function set_access_control_allow_credentials(value) {
		return js.Syntax.code("{0}['access-control-allow-credentials'] = {1}", this, value);
	}

	public var access_control_max_age(get, set):String;

	extern inline function get_access_control_max_age() {
		return js.Syntax.code("{0}['access-control-max-age']", this);
	}

	extern inline function set_access_control_max_age(value) {
		return js.Syntax.code("{0}['access-control-max-age'] = {1}", this, value);
	}

	public var access_control_request_method(get, set):String;

	extern inline function get_access_control_request_method() {
		return js.Syntax.code("{0}['access-control-request-method']", this);
	}

	extern inline function set_access_control_request_method(value) {
		return js.Syntax.code("{0}['access-control-request-method'] = {1}", this, value);
	}

	public var content_encoding(get, set):String;

	extern inline function get_content_encoding() {
		return js.Syntax.code("{0}['content-encoding']", this);
	}

	extern inline function set_content_encoding(value) {
		return js.Syntax.code("{0}['content-encoding'] = {1}", this, value);
	}

	public var content_language(get, set):String;

	extern inline function get_content_language() {
		return js.Syntax.code("{0}['content-language']", this);
	}

	extern inline function set_content_language(value) {
		return js.Syntax.code("{0}['content-language'] = {1}", this, value);
	}

	public var content_length(get, set):String;

	extern inline function get_content_length() {
		return js.Syntax.code("{0}['content-length']", this);
	}

	extern inline function set_content_length(value) {
		return js.Syntax.code("{0}['content-length'] = {1}", value);
	}

	public var content_location(get, set):String;

	extern inline function get_content_location() {
		return js.Syntax.code("{0}['content-location']", this);
	}

	extern inline function set_content_location(value) {
		return js.Syntax.code("{0}['content-location']", this, value);
	}

	public var content_md5(get, set):String;

	extern inline function get_content_md5() {
		return js.Syntax.code("{0}['content-md5']", this);
	}

	extern inline function set_content_md5(value) {
		return js.Syntax.code("{0}['content-md5'] = {1}", this, value);
	}

	public var content_range(get, set):String;

	extern inline function get_content_range() {
		return js.Syntax.code("{0}['content-range']", this);
	}

	extern inline function set_content_range(value) {
		return js.Syntax.code("{0}['content-range'] = {1}", this, value);
	}

	public var content_type(get, set):String;

	extern inline function get_content_type() {
		return js.Syntax.code("{0}['content-type']", this);
	}

	extern inline function set_content_type(value) {
		return js.Syntax.code("{0}['content-type'] = {1}", this, value);
	}

	public var date(get, set):String;

	extern inline function get_date() {
		return js.Syntax.code("{0}['date']", this);
	}

	extern inline function set_date(value) {
		return js.Syntax.code("{0}['date'] = {1}", value);
	}

	public var dnt(get, set):String;

	extern inline function get_dnt() {
		return js.Syntax.code("{0}['dnt']", this);
	}

	extern inline function set_dnt(value) {
		return js.Syntax.code("{0}['dnt'] = {1}", this, value);
	}

	public var etag(get, set):String;

	extern inline function get_etag() {
		return js.Syntax.code("{0}['etag']", this);
	}

	extern inline function set_etag(value) {
		return js.Syntax.code("{0}['etag'] = {1}", this, value);
	}

	public var expires(get, set):String;

	extern inline function get_expires() {
		return js.Syntax.code("{0}['expired']", this);
	}

	extern inline function set_expires(value) {
		return js.Syntax.code("{0}['expired'] = {1}", this, value);
	}

	public var from(get, set):String;

	extern inline function get_from() {
		return js.Syntax.code("{0}['from']", this);
	}

	extern inline function set_from(value) {
		return js.Syntax.code("{0}['from'] = {1}", this, value);
	}

	public var if_match(get, set):String;

	extern inline function get_if_match() {
		return js.Syntax.code("{0}['if-match']", this);
	}

	extern inline function set_if_match(value) {
		return js.Syntax.code("{0}['if-match'] = {1}", this, value);
	}

	public var if_modified_since(get, set):String;

	extern inline function get_if_modified_since() {
		return js.Syntax.code("{0}['if-modified-since']", this);
	}

	extern inline function set_if_modified_since(value) {
		return js.Syntax.code("{0}['if-modified-since'] = {1}", this, value);
	}

	public var if_none_match(get, set):String;

	extern inline function get_if_none_match() {
		return js.Syntax.code("{0}['if-none-match']", this);
	}

	extern inline function set_if_none_match(value) {
		return js.Syntax.code("{0}['if-none-match'] = {1}", this, value);
	}

	public var if_range(get, set):String;

	extern inline function get_if_range() {
		return js.Syntax.code("{0}['if-range']", this);
	}

	extern inline function set_if_range(value) {
		return js.Syntax.code("{0}['if-range'] = {1}", this, value);
	}

	public var if_unmodified_since(get, set):String;

	extern inline function get_if_unmodified_since() {
		return js.Syntax.code("{0}['if-unmodified-since']", this);
	}

	extern inline function set_if_unmodified_since(value) {
		return js.Syntax.code("{0}['if-unmodified-since'] = {1}", this, value);
	}

	public var last_modified(get, set):String;

	extern inline function get_last_modified() {
		return js.Syntax.code("{0}['last-modified']", this);
	}

	extern inline function set_last_modified(value) {
		return js.Syntax.code("{0}['last-modified'] = {1}", this, value);
	}

	public var location(get, set):String;

	extern inline function get_location() {
		return js.Syntax.code("{0}['location']", this);
	}

	extern inline function set_location(value) {
		return js.Syntax.code("{0}['location'] = {1}", this, value);
	}

	public var max_forwards(get, set):String;

	extern inline function get_max_forwards() {
		return js.Syntax.code("{0}['max-forwards']", this);
	}

	extern inline function set_max_forwards(value) {
		return js.Syntax.code("{0}['max-forwards'] = {1}", this, value);
	}

	public var proxy_authorization(get, set):String;

	extern inline function get_proxy_authorization() {
		return js.Syntax.code("{0}['proxy-authorization']", this);
	}

	extern inline function set_proxy_authorization(value) {
		return js.Syntax.code("{0}['proxy-authorization'] = {1}", this, value);
	}

	public var range(get, set):String;

	extern inline function get_range() {
		return js.Syntax.code("{0}['range']", this);
	}

	extern inline function set_range(value) {
		return js.Syntax.code("{0}['range'] = {1}", this, value);
	}

	public var referer(get, set):String;

	extern inline function get_referer() {
		return js.Syntax.code("{0}['referer']", this);
	}

	extern inline function set_referer(value) {
		return js.Syntax.code("{0}['referer'] = {1}", this, value);
	}

	public var retry_after(get, set):String;

	extern inline function get_retry_after() {
		return js.Syntax.code("{0}['retry-after']", this);
	}

	extern inline function set_retry_after(value) {
		return js.Syntax.code("{0}['retry-after'] = {1}", this, value);
	}

	public var tk(get, set):String;

	extern inline function get_tk() {
		return js.Syntax.code("{0}['tk']", this);
	}

	extern inline function set_tk(value) {
		return js.Syntax.code("{0}['tk'] = {1}", this, value);
	}

	public var upgrade_insecure_requests(get, set):String;

	extern inline function get_upgrade_insecure_requests() {
		return js.Syntax.code("{0}['upgrade-insecure-requests']", this);
	}

	extern inline function set_upgrade_insecure_requests(value) {
		return js.Syntax.code("{0}['upgrade-insecure-requests'] = {1}", this, value);
	}

	public var user_agent(get, set):String;

	extern inline function get_user_agent() {
		return js.Syntax.code("{0}['user-agent']", this);
	}

	extern inline function set_user_agent(value) {
		return js.Syntax.code("{0}['user-agent'] = {1}", this, value);
	}

	public var x_content_type_options(get, set):String;

	extern inline function get_x_content_type_options() {
		return js.Syntax.code("{0}['x-content-type-options']", this);
	}

	extern inline function set_x_content_type_options(value) {
		return js.Syntax.code("{0}['x-content-type-options'] = {1}", this, value);
	}

	@:op([]) extern public inline function get(key:String) {
		return js.Syntax.code("{0}[{1}]", this, key);
	}

	@:op([]) extern public inline function set(key:String, value:Dynamic) {
		return js.Syntax.code("{0}[{1}] = {2}", this, key, value);
	}
}

typedef CreateServerOptions = {
	/**
		Sets the maximum dynamic table size for deflating header fields.
		Default: `4Kib`.
	**/
	@:optional var maxDeflateDynamicTableSize:Float;

	/**
		Sets the maximum memory that the `Http2Session` is permitted to use.
		The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
		The minimum value allowed is `1`.
		This is a credit based limit, existing `Http2Streams` may cause this limit to be exceeded,
		but new `Http2Stream` instances will be rejected while this limit is exceeded.
		The current number of `Http2Stream` sessions, the current memory use of the header compression
		tables, current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are
		all counted towards the current limit.
		Default: `10`.
	**/
	@:optional var maxSessionMemory:Float;

	/**
		Sets the maximum number of header entries.
		The minimum value is `4`.
		Default: `128`.
	**/
	@:optional var maxHeaderListPairs:Int;

	/**
		Sets the maximum number of outstanding, unacknowledged pings.
		Default: `10`.
	**/
	@:optional var maxOutstandingPings:Int;

	/**
		Sets the maximum allowed size for a serialized, compressed block of headers.
		Attempts to send headers that exceed this limit will result in a `'frameError'` event being emitted
		and the stream being closed and destroyed.
	**/
	@:optional var maxSendHeaderBlockLength:Int;

	/**
		The strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
		Default: `http2.Constants.PADDING_STRATEGY_NONE`.
	**/
	@:optional var paddingStrategy:Int;

	/**
		Sets the maximum number of concurrent streams for the remote peer
		as if a `SETTINGS` frame had been received.
		Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
		Default: `100`.
	**/
	@:optional var peerMaxConcurrentStreams:Int;

	/**
		Sets the maximum number of invalid frames that will be tolerated before the session is closed.
		Default: `1000`.
	**/
	@:optional var maxSessionInvalidFrames:Int;

	/**
		Sets the maximum number of rejected upon creation streams that will be tolerated
		before the session is closed.
		Each rejection is associated with an `NGHTTP2_ENHANCE_YOUR_CALM` error that
		should tell the peer to not open any more streams, continuing to open streams is therefore
		regarded as a sign of a misbehaving peer.
		Default: `100`.
	**/
	@:optional var maxSessionRejectedStreams:Int;

	/**
		The initial settings to send to the remote peer upon connection.
	**/
	@:optional var settings:Http2SettingsObject;

	/**
		Specifies the IncomingMessage class to used for HTTP/1 fallback.
		Useful for extending the original `http.IncomingMessage`.
		Default: `http.IncomingMessage`.
	**/
	@:optional var Http1IncomingMessage:IncomingMessage;

	/**
		Specifies the ServerResponse class to used for HTTP/1 fallback.
		Useful for extending the original `http.ServerResponse`.
		Default: `http.ServerResponse`.
	**/
	@:optional var Http1ServerResponse:js.node.http.ServerResponse;

	/**
		Specifies the `Http2ServerRequest` class to use.
		Useful for extending the original `Http2ServerRequest`.
		Default: `Http2ServerRequest`.
	**/
	@:optional var Http2ServerRequest:Http2ServerRequest;

	/**
		Specifies the `Http2ServerResponse` class to use.
		Useful for extending the original `Http2ServerResponse`.
		Default: `Http2ServerResponse`.
	**/
	@:optional var Http2ServerResponse:Http2ServerResponse;

	// followings are from `Net.createServer()`

	/**
		Indicates whether half-opened TCP connections are allowed.
		Default: `false`.
	**/
	@:optional var allowHalfOpen:Bool;

	/**
		Indicates whether the socket should be paused on incoming connections.
		Default: `false`.
	**/
	@:optional var pauseOnConnect:Bool;
}

typedef CreateSecureServerOptions = {
	/**
		Incoming client connections that do not support HTTP/2 will be downgraded to HTTP/1.x when set to `true`.
		See the `'unknownProtocol'` event.
		See ALPN negotiation.
		Default: `false`.
	**/
	@:optional var allowHttp1:Bool;

	/**
		Sets the maximum dynamic table size for deflating header fields.
		Default: `4Kib`.
	**/
	@:optional var maxDeflateDynamicTableSize:Float;

	/**
		Sets the maximum memory that the `Http2Session` is permitted to use.
		The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
		The minimum value allowed is `1`.
		This is a credit based limit, existing `Http2Streams` may cause this limit to be exceeded,
		but new `Http2Stream` instances will be rejected while this limit is exceeded.
		The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
		current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted
		towards the current limit.
		Default: `10`.
	**/
	@:optional var maxSessionMemory:Float;

	/**
		Sets the maximum number of header entries.
		The minimum value is `4`.
		Default: `128`.
	**/
	@:optional var maxHeaderListPairs:Int;

	/**
		Sets the maximum number of outstanding, unacknowledged pings.
		Default: `10`.
	**/
	@:optional var maxOutstandingPings:Int;

	/**
		Sets the maximum allowed size for a serialized, compressed block of headers.
		Attempts to send headers that exceed this limit will result in a `'frameError'` event
		being emitted and the stream being closed and destroyed.
	**/
	@:optional var maxSendHeaderBlockLength:Int;

	/**
		Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
		Default: `http2.Constants.PADDING_STRATEGY_NONE`.
	**/
	@:optional var paddingStrategy:Int;

	/**
		Sets the maximum number of concurrent streams for the remote peer
		as if a SETTINGS frame had been received.
		Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
		Default: `100`.
	**/
	@:optional var peerMaxConcurrentStreams:Int;

	/**
		Sets the maximum number of invalid frames that will be tolerated before the session is closed.
		Default: `1000`.
	**/
	@:optional var maxSessionInvalidFrames:Int;

	/** 
		Sets the maximum number of rejected upon creation streams that will be tolerated
		before the session is closed.
		Each rejection is associated with an `NGHTTP2_ENHANCE_YOUR_CALM` error that should tell
		the peer to not open any more streams, continuing to open streams is therefore regarded
		as a sign of a misbehaving peer.
		Default: `100`.
	**/
	@:optional var maxSessionRejectedStreams:Int;

	/**
		The initial settings to send to the remote peer upon connection.
	**/
	@:optional var settings:Http2SettingsObject;

	/**
		An array of origin strings to send within an `ORIGIN` frame immediately following creation of a new server `Http2Session`.
	**/
	@:optional var origins:Array<String>;

	// followings are from `Tls.createServer()`

	/**
		An array of strings, `Buffer`s or `ArrayBufferView`s, or a single `Buffer` or `ArrayBufferView`
		containing the supported ALPN protocols.
		Buffers should have the format [len][name][len][name]...
		e.g. `0x05hello0x05world`, where the first byte is the length of the next protocol name.
		Passing an array is usually much simpler,
		e.g. `['hello', 'world']`. (Protocols should be ordered by their priority.)
	**/
	// @:optional var ALPNProtocols:ALPNProtocolsType;
	@:optional var ALPNProtocols:Dynamic; // TODO: udpate tls earlier

	/**
		Name of an OpenSSL engine which can provide the client certificate.
	**/
	@:optional var clientCertEngine:String;

	/**
		If `true`, `tls.TLSSocket.enableTrace()` will be called on new connections.
		Tracing can be enabled after the secure connection is established, but this option must be used to trace the secure connection setup.
		Default: `false`.
	**/
	@:optional var enableTrace:Bool;

	/**
		Abort the connection if the SSL/TLS handshake does not finish in the specified number of milliseconds.
		A `'tlsClientError'` is emitted on the tls.Server object whenever a handshake times out.
		Default: `120000` (120 seconds).
	**/
	@:optional var handshakeTimeout:Int;

	/**
		If not `false` the server will reject any connection which is not authorized with the list of supplied CAs.
		This option only has an effect if `requestCert` is `true`.
		Default: `true`.
	**/
	@:optional var rejectUnauthorized:Bool;

	/**
		If `true` the server will request a certificate from clients that connect and attempt to verify that certificate.
		Default: `false`.
	**/
	@:optional var requestCert:Bool;

	/**
		The number of seconds after which a TLS session created by the server will no longer be resumable.
		Default: `300`.
	**/
	@:optional var sessionTimeout:Int;

	/**
		A function that will be called if the client supports SNI TLS extension.
		Two arguments will be passed when called: `servername` and `cb`.
		`SNICallback` should invoke `cb(null, ctx)`, where `ctx` is a `SecureContext` instance.
		(`tls.createSecureContext(...)` can be used to get a proper `SecureContext`.)
		If `SNICallback` wasn't provided the default callback with high-level API will be used.
	**/
	@:optional var SNICallback:#if (haxe_ver >= 4) (servername : String, cb : (Error->SecureContext)) -> Void; #else String->(Error->SecureContext)->Void; #end

	/**
		48-bytes of cryptographically strong pseudo-random data.
	**/
	@:optional var ticketKeys:Buffer;

	// followings are from `tls.SecureContext` options.

	/**
		Optionally override the trusted CA certificates.
	**/
	@:optional var ca:EitherType<EitherType<String, Buffer>, Array<EitherType<String, Buffer>>>;

	/**
		Cert chains in PEM format.
	**/
	@:optional var cert:EitherType<EitherType<String, Buffer>, Array<EitherType<String, Buffer>>>;

	/**
		Colon-separated list of supported signature algorithms.
	**/
	@:optional var sigalgs:String;

	/**
		Cipher suite specification, replacing the default.
	**/
	@:optional var ciphers:String;

	/**
		PEM encoded CRLs (Certificate Revocation Lists)
	**/
	@:optional var crl:EitherType<EitherType<String, Array<String>>, EitherType<Buffer, Array<Buffer>>>;

	/**
		Diffie Hellman parameters, required for Perfect Forward Secrecy.
	**/
	@:optional var dhparam:EitherType<String, Buffer>;

	/**
		A string describing a named curve or a colon separated list of curve NIDs or names,
		for example `P-521:P-384:P-256`, to use for ECDH key agreement.
	**/
	@:optional var ecdhCurve:String;

	/**
		Attempt to use the server's cipher suite preferences instead of the client's.
	**/
	@:optional var honorCipherOrder:Bool;

	/**
		Private keys in PEM format.
	**/
	@:optional var key:EitherType<EitherType<String, Array<String>>, EitherType<EitherType<Buffer, Array<Buffer>>, Array<Dynamic>>>;

	/**
		Name of an OpenSSL engine to get private key from.
	**/
	@:optional var privateKeyEngine:String;

	/**
		Identifier of a private key managed by an OpenSSL engine.
	**/
	@:optional var privateKeyIdentifier:String;

	/**
		Optionally set the maximum TLS version to allow.
	**/
	@:optional var maxVersion:String;

	/**
		Optionally set the minumum TLS version to allow.
	**/
	@:optional var minVersion:String;

	/**
		Shared passphrase used for a single private key and/or a PFX.
	**/
	@:optional var passphrase:String;

	/**
		PFX or PKCS12 encoded private key and certificate chain.
	**/
	@:optional var pfx:EitherType<EitherType<String, Array<String>>, EitherType<EitherType<Buffer, Array<Buffer>>, Array<Dynamic>>>;

	/**
		Optionally affect the OpenSSL protocol behavior, which is not usually necessary.
	**/
	@:optional var secureOptions:Int;

	/**
		Legacy mechanism to select the TLS protocol version to use, it does not support independent control of the minimum and maximum version,
		and does not support limiting the protocol to TLSv1.3.
		Use minVersion and maxVersion instead.
	**/
	@:optional var secureProtocol:String;

	/**
		Opaque identifier used by servers to ensure session state is not shared between applications.
		Unused by clients.
	**/
	@:optional var sessionIdContext:String;

	// followings are from `net.CreateServer()` options.

	/**
		If true, then the socket won't automatically send a FIN packet
		when the other end of the socket sends a FIN packet.
		The socket becomes non-readable, but still writable. You should call the `end` method explicitly.
		See `end` event for more information.
		Default: false
	**/
	@:optional var allowHalfOpen:Bool;

	/**
		If true, then the socket associated with each incoming connection will be paused,
		and no data will be read from its handle.
		This allows connections to be passed between processes without any data being read by the original process.
		To begin reading data from a paused socket, call `resume`.
		Default: false
	**/
	@:optional var pauseOnConnect:Bool;
}

typedef ConnectOptions = {
	/**
		Sets the maximum dynamic table size for deflating header fields.
		Default: `4Kib`.
	**/
	@:optional var maxDeflateDynamicTableSize:Float;

	/**
		Sets the maximum memory that the `Http2Session` is permitted to use.
		The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
		The minimum value allowed is `1`.
		This is a credit based limit, existing `Http2Streams` may cause this limit to be exceeded,
		but new `Http2Stream` instances will be rejected while this limit is exceeded.
		The current number of `Http2Stream` sessions, the current memory use of the header compression
		tables, current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are
		all counted towards the current limit.
		Default: `10`.
	**/
	@:optional var maxSessionMemory:Float;

	/**
		Sets the maximum number of header entries. The minimum value is `1`.
		Default: `128`.
	**/
	@:optional var maxHeaderListPairs:Int;

	/**
		Sets the maximum number of outstanding, unacknowledged pings.
		Default: `10`.
	**/
	@:optional var maxOutstandingPings:Int;

	/**
		Sets the maximum number of reserved push streams the client will accept at any given time.
		Once the current number of currently reserved push streams exceeds reaches this limit,
		new push streams sent by the server will be automatically rejected.
		The minimum allowed value is 0.
		The maximum allowed value is 2^32-1.
		A negative value sets this option to the maximum allowed value.
		Default: `200`.
	**/
	@:optional var maxReservedRemoteStreams:Int;

	/**
		Sets the maximum allowed size for a serialized, compressed block of headers.
		Attempts to send headers that exceed this limit will result in a `'frameError'` event
		being emitted and the stream being closed and destroyed.
	**/
	@:optional var maxSendHEaderBlockLength:Int;

	/**
		Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
		Default: `http2.Constants.PADDING_STRATEGY_NONE`.
	**/
	@:optional var paddingStrategy:Int;

	/**
		Sets the maximum number of concurrent streams for the remote peer
		as if a `SETTINGS` frame had been received.
		Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
		Default: 100.
	**/
	@:optional var peerMaxConcurrentStreams:Int;

	/**
		The initial settings to send to the remote peer upon connection.
	**/
	@:optional var settings:Http2SettingsObject;

	/**
		An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
		and returns any `Duplex` stream that is to be used as the connection for this session.
	**/
	@:optional var createConnection:Url->ConnectOptions->Duplex<Dynamic>;

	// followings are from `Tls.connect()`

	/**
		See `tls.createServer()`
	**/
	@:optional var enableTrace:Bool;

	/**
		Host the client should connect to. Default: `'localhost'`.
	**/
	@:optional var host:String;

	/**
		Port the client should connect to.
	**/
	@:optional var port:Int;

	/**
		Creates Unix socket connection to path.
		If this option is specified, host and port are ignored.
	**/
	@:optional var path:String;

	/**
		Establish secure connection on a given socket rather than creating a new socket.
		Typically, this is an instance of `net.Socket`, but any `Duplex` stream is allowed.
		If this option is specified, `path`, `host` and `port` are ignored, except for certificate validation.
		Usually, a socket is already connected when passed to `tls.connect()`, but it can be connected later.
		Connection/disconnection/destruction of socket is the user's responsibility;
		calling `tls.connect()` will not cause `net.connect()` to be called.
	**/
	@:optional var socket:Socket;

	/**
		If the `socket` option is missing, indicates whether or not to allow the internally created socket to be half-open,
		otherwise the option is ignored.
		See the `allowHalfOpen` option of `net.Socket` for details.
		Default: `false`.
	**/
	@:optional var allowHalfOpen:Bool;

	/**
		If not `false`, the server certificate is verified against the list of supplied CAs.
		An `'error'` event is emitted if verification fails; `err.code` contains the OpenSSL error code.
		Default: true.
	**/
	@:optional var rejectUnauthorized:Bool;

	/**
		An array of strings, `Buffer`s or `ArrayBufferView`s, or a single `Buffer` or `ArrayBufferView` containing the supported ALPN protocols.
		`Buffer`s should have the format `[len][name][len][name]...`
		e.g. `'\x08http/1.1\x08http/1.0'`, where the len byte is the length of the next protocol name.
		Passing an array is usually much simpler, e.g. `['http/1.1', 'http/1.0']`.
		Protocols earlier in the list have higher preference than those later.
	**/
	// @:optional var ALPNProtocols:ALPNProtocolsType;
	@:optional var ALPNProtocols:Dynamic; // TODO: update tls enableTrace

	/**
		Server name for the SNI (Server Name Indication) TLS extension.
		It is the name of the host being connected to, and must be a host name, and not an IP address.
		It can be used by a multi-homed server to choose the correct certificate to present to the client,
		see the `SNICallback` option to `tls.createServer()`.
	**/
	@:optional var servername:String;

	/**
		A callback function to be used (instead of the builtin `tls.checkServerIdentity()` function)
		when checking the server's hostname (or the provided `servername` when explicitly set) against the certificate.
		This should return an <Error> if verification fails.
		The method should return `null` if the `servername` and `cert` are verified.
	**/
	// @:optional var checkServerIdentity:String->CertificateObject->Null<Error>;
	@:optional var checkServerIdentity:String->Dynamic->Null<Error>; // TODO: udpate tls earlier

	/**
		A `Buffer` instance, containing TLS session.
	**/
	@:optional var session:Buffer;

	/**
		Minimum size of the DH parameter in bits to accept a TLS connection.
		When a server offers a DH parameter with a size less than `minDHSize`, the TLS connection is destroyed and an error is thrown.
		Default: `1024`.
	**/
	@:optional var minDHsize:Int;

	/**
		TLS context object created with `tls.createSecureContext()`.
		If a `secureContext` is not provided, one will be created by passing the entire `options` object to `tls.createSecureContext()`.
	**/
	@:optional var secureContext:SecureContext;

	// followings are from SecureContext

	/**
		Optionally override the trusted CA certificates.
	**/
	@:optional var ca:EitherType<EitherType<String, Buffer>, Array<EitherType<String, Buffer>>>;

	/**
		Cert chains in PEM format.
	**/
	@:optional var cert:EitherType<EitherType<String, Buffer>, Array<EitherType<String, Buffer>>>;

	/**
		Colon-separated list of supported signature algorithms.
	**/
	@:optional var sigalgs:String;

	/**
		Cipher suite specification, replacing the default.
	**/
	@:optional var ciphers:String;

	/**
		Name of an OpenSSL engine which can provide the client certificate.
	**/
	@:optional var clientCertEngine:String;

	/**
		PEM encoded CRLs (Certificate Revocation Lists)
	**/
	@:optional var crl:EitherType<EitherType<String, Array<String>>, EitherType<Buffer, Array<Buffer>>>;

	/**
		Diffie Hellman parameters, required for Perfect Forward Secrecy.
	**/
	@:optional var dhparam:EitherType<String, Buffer>;

	/**
		A string describing a named curve or a colon separated list of curve NIDs or names,
		for example `P-521:P-384:P-256`, to use for ECDH key agreement.
	**/
	@:optional var ecdhCurve:String;

	/**
		Attempt to use the server's cipher suite preferences instead of the client's.
	**/
	@:optional var honorCipherOrder:Bool;

	/**
		Private keys in `PEM` format.
	**/
	@:optional var key:EitherType<EitherType<String, Array<String>>, EitherType<EitherType<Buffer, Array<Buffer>>, Array<Dynamic>>>;

	/**
		Name of an OpenSSL engine to get private key from.
	**/
	@:optional var privateKeyEngine:String;

	/**
		Identifier of a private key managed by an OpenSSL engine.
	**/
	@:optional var privateKeyIdentifier:String;

	/**
		Optionally set the maximum TLS version to allow.
	**/
	@:optional var maxVersion:String;

	/**
		Optionally set the minumum TLS version to allow.
	**/
	@:optional var minVersion:String;

	/**
		Shared passphrase used for a single private key and/or a PFX.
	**/
	@:optional var passphrase:String;

	/**
		PFX or PKCS12 encoded private key and certificate chain.
	**/
	@:optional var pfx:EitherType<EitherType<String, Array<String>>, EitherType<EitherType<Buffer, Array<Buffer>>, Array<Dynamic>>>;

	/**
		Optionally affect the OpenSSL protocol behavior, which is not usually necessary.
	**/
	@:optional var secureOptions:Int;

	/**
		Legacy mechanism to select the TLS protocol version to use, it does not support independent control of the minimum and maximum version,
		and does not support limiting the protocol to TLSv1.3.
		Use minVersion and maxVersion instead.
	**/
	@:optional var secureProtocol:String;

	/**
		Opaque identifier used by servers to ensure session state is not shared between applications.
		Unused by clients.
	**/
	@:optional var sessionIdContext:String;
}
